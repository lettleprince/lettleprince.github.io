---
layout: post
title: "权益证明问题 —— Proof of Stake FAQ"
description: ""
category: articles
tags: [Blockchain]
comments: true
---

[ethereum wiki](https://github.com/ethereum/wiki) 中的汉语繁体翻译实在是读不通顺，还不如看英文，顺便翻译下。原文：[Proof of Stake FAQ](https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ)

## 什么是权益证明

权益证明（Proof of Stake，PoS）是一种公有（区块）链的共识算法，它基于网络中验证者的经济利益。在基于工作证明（PoW）的公有链（例如比特币和以太坊的之前的实现）中，该算法通过奖励谜题计算的参与者来验证交易并创建新的区块（即挖矿）。在基于 PoS 的公有链中（例如以太坊推出的 Casper 实现），通过一组验证者轮流针对下一区块进行提议并投票，每个验证者的投票权重取决于其存款（deposit）的大小（也就是权益）。PoS 在**安全性、降低中心化风险、能源效率方面有显著优势**。

通常，PoS 的算法如下。区块链会追踪一组验证者，任何持有区块链基础加密货币（对于以太坊来说就是 eth）的人都可以通过发送一种特殊类型的交易，**将其以太币锁定在存款中**来成为验证者。然后通过当前所有的验证者参与的共识算法完成新区块的创建和验证。

共识算法有很多种，还有很多方法可以将奖励分配给参与共识算法的验证者，所以 PoS 也就有很多方式。从算法的角度来看，有两种主要的类型：基于链的证明和 [BFT-style](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance) （拜占庭容錯）证明。

在基于链的权益证明中，算法每隔一段时间会伪随机地选择出一个验证者（例如，以 10 秒作为间隔周期），赋予其创建下一个区块的权利，而且新区块必须指向前一区块（通常是当前最长链的最后一个区块），随着时间的推移，区块链便会不断地增长。

在 BFT 权益证明中，验证者会被**随机地**分配创建区块的权利，但是*验证区块的合法性*则通过一个多轮的投票过程完成。验证者在每一轮为某个区块进行“投票”，多轮投票之后，所有的（诚实的和在线的）验证者会决定是否有效，以及是否达成永久共识。注意区块一直会在链中，关键的区别在于区块的共识由本身决定，而并不取决于其后面区块的多少（这一句不能确定，我的理解是这样的）。

## PoS 的优势

请参阅 [权益证明设计理念](https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51) 中更完整的论述。

概括：

- **不需要消耗大量的电力**就可以保证区块链的安全性。据估计，比特币和以太坊的共识机制，每天都会耗费超过 100 万美元的电力和硬件成本。

- 由于不再需要大量能源，就**不需要通过尽可能多的发行新币**来激励参与者，从而降低网络的压力。理论上甚至有可能出现负净发行，其中一部分交易费用被“烧掉”，因此供应随着时间的推移而下降。

- 权益证明为更广泛的使用博弈论机制设计的技术敞开了大门，以便更好地**阻止中心化垄断**的形成，以及（如果确实形成了中心化垄断）伤害网络的行为（例如像工作证明中的 selfish mining）。

- **降低中心化风险**之后，经济规模的扩大便不是问题。在工作量证明机制中，当资本多到一定程度，便可以投入更大规模的生产设备，拉大和其他人的差距（投入一千万的成本所获得的收益不只是投入一百万的十倍）。而在权益证明机制中，一千万的投资只能保证获取一百万投资的十倍的收益。

- 相对于工作量证明，能够使用经济处罚来**大大提高各种形式的 51％ 攻击的成本**——正如 Vlad Zamfir 所说的，“只要参与了 51％ 攻击，ASIC 矿场就会被烧毁。”

## 权益证明如何适应传统的拜占庭容错研究？

拜占庭容错研究有几个基本结果适用于所有共识算法，包括传统的一致性算法（例如 PBFT），也包括任何权益证明算法以及，使用了适当的数学建模的工作量证明。

结论包含：

- [CAP 理论](https://en.wikipedia.org/wiki/CAP_theorem) —— 在网络分区发生时，一致性和可用性只能二选其一，无法两者兼顾。直觉上的论据很简单：网络分成两半，在其中一半网络中发起“向 A 支付 10 元”的交易，而在另一半网络中发起“向 B 支付 10 元”的交易，这样系统会变的不可用。要么这一个或两个交易不被处理，要么网络变得不一致（一半网络认可第一个交易，而另一个网络将会认可第二个交易）。请注意，CAP 定理与扩展性无关；它同样适用于分片和非分片系统。

- [FLP impossibility](http://the-paper-trail.org/blog/a-brief-tour-of-flp-impossibility/) —— 在异步设置中(即在两个正常的节点之间，网络延迟也没有上限)，如果即使存在单个故障/不诚实节点，也不存在能保证在任何特定的有限时间内达成一致的算法。请注意，[“Las Vegas”](https://en.wikipedia.org/wiki/Las_Vegas_algorithm) 算法在每轮都有一定的概率达成共识，从而在 T 秒内达到一致，随着 T 增长，概率指数地接近 1。实际上它被很多成功的共识算法所采用。

- 容错上限 —— 依据 [DLS 论文](http://groups.csail.mit.edu/tds/papers/Lynch/jacm88.pdf)可以得到：1）在部分同步网络模型中运行的协议（例如，网络延迟有一定的限制，但是无法提前知道具体值）最多可容纳 1/3 的拜占庭（Byzantine）故障。2）异步网络中运行的确定性协议（即网络延迟没有限制）无法容纳任何错误（但论文中没有提及 [randomized algorithms](http://link.springer.com/chapter/10.1007%2F978-3-540-77444-0_7) 可以将容错率提高到 1/3）。3）同步模型中协议（即网络延迟保证小于已知的 d），竟然可以进行 100% 的容错，但如果超过 1/2 的节点有问题时，会有一些限制条件。要注意的是，我们关注的是“可认证的拜占庭模型（authenticated Byzantine）”，而不是单纯的“拜占庭模型”。“可认证的”是指，我们可以在我们的算法中使用公钥密码算法，而这些算法当前已经研究得非常好，而且非常便宜。

工作量证明已经[由 Andrew Miller 等人严格分析](https://socrates1024.s3.amazonaws.com/consensus.pdf)过，并且适合作为同步网络模型的可靠算法。我们可以将网络建模为由几乎无限的节点组成，每个节点代表非常小的计算能力单位，并且在给定的时间段内能够创建块的可能性非常小。在该模型中，假设网络延迟为零，该协议具有 50％ 的容错能力（实际观察到的情况，以太坊约为 46％，比特币约为 49.5％），但如果网络等待时间等于阻塞时间，则下降到33％，并且随着网络等待时间接近无穷大而下降到零。

由于所有验证者都已知身份（stable Ethereum addresses）并且网络会记录验证者的总数，因此权益证明机制共识更直接地适用于拜占庭容错共识模式。权益证明机制的研究一般分为两条线路，一条研究同步网络模型，另一条研究部分同步的网络模型。“基于链式”权益证明机制几乎总是依赖于同步网络模型，并且它们的安全性可以用类似于[工作量证明机制](http://nakamotoinstitute.org/static/docs/anonymous-byzantine-consensus.pdf)的方式得到正式验证。另外一条线路，将部分同步的网络中的传统拜占庭容错共识算法和已存在的权益证明机制相连接，但要解释起来会更加复杂；我们将在后面的章节中详细介绍。

工作量证明机制和链式权益证明机制选择了可用性而不是一致性，但 BFT 风格的共识算法更倾向于一致性。[Tendermint](https://github.com/tendermint/tendermint) 明确选择一致性，而 Casper 使用了偏向可用性的混合模型，同时尽可能提供一致性，并保证链上的应用和客户端在任意时间都能知道当前一致性的程度。

注意，Ittay Eyal 和 Emin Gun Sirer 的 [selfish mining](https://bitcoinmagazine.com/articles/selfish-mining-a-25-attack-against-the-bitcoin-network-1383578440) 研究指出，根据网络模型，比特币挖掘的激励兼容性性设置了 25％ 和 33％ 的限制（即，只有在 25% 或 33% 的矿工同谋不可能发生的前提下，挖矿的机制才是激励兼容的）。此结论和传统的共识算法的结论无关，因为传统共识算法的结论并没有牵涉到激励兼容性。

什么是“无成本风险”问题及该如何解决这个问题？

在许多早期（基于所有链条）的权益证明算法中，包括 Peercoin，只有生产区块的奖励，并没有处罚。这会导致不良后果，在存在多个竞争链（分叉）的情况下，验证者会产生在每条链上产生区块的动机，如下：

![01](../../../../images/20180227-pos/01.png)

在工作量证明机制中，这样做会导致矿工的算力被分散，导致利润下降：

![02](../../../../images/20180227-pos/02.png)

于是会造成：如果所有参与者都是狭义上经济理性的话，那么即使没有攻击者，区块链也无法达成共识。如果有攻击者，那么攻击者只需要压倒无私的节点（即只对原始链投票），无需针对理性节点（在原始链和攻击者的链上都投票）。工作量证明中，攻击者必须压制（至少威胁到，参考：[P + epsilon attacks](https://blog.ethereum.org/2015/01/28/p-epsilon-attack/)）无私节点和理性节点。

有些人认为，利益相关者有正确的动机，且只会下注在最长的链上，好让他们的投资能够保值。然而这忽略了这种激励会受制于 [tragedy of the commons](https://en.wikipedia.org/wiki/Tragedy_of_the_commons)：每个个人利益相关者可能只有 1％ 的机会成为“关键”（即，如果他们是否参与影响攻击的成败），所以用来买通他们的贿赂金额只需要是他们总投资金额的 1%。因此，全部的贿赂仅为所有投资总额的 0.5-1%。另外，这一观点意味着任何零失败的情况都不是一个稳定的均衡，就好像失败的机会是零，那么每个人都有 0％ 的关键机会。

有两种方式解决这个问题。第一个为 [“Slasher”](https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/)，并由 [Iddo Bentov 进一步发展](https://arxiv.org/pdf/1406.5694.pdf)。当验证者同时在多个链上创建区块，则会将错误行为证明（比如两个有冲突的签名区块头）记录进区块链，并在稍后的时间点通过适当的扣除犯错的验证者的资金来惩罚他们。改动如下：

![03](../../../../images/20180227-pos/03.png)

请注意，为了使该算法起作用，需要提前知道验证者有哪些人。否则，当 A 链可下注时就下注 A 链，当 B 链可下注时就下注 B 链，两条都可下注时，就下注最长的链。只有在两条链的每个区块选择的验证器都一样的情况下才能避免，这需要在分叉前进行验证器的选择。

这个方案有缺陷，需要节点频繁上线来获取安全可信的区块链状态，并且让 medium-range 的验证者的共谋攻击有可能发生（例如连续 30 个连续的验证者中有 25 个联合起来对之前的 19 个 区块实施 51％ 的攻击）。如何这些风险被认为是可接受的，那么这个方案会运行良好。

第二个策略是单纯的惩罚在错误链上创建区块的的验证者。也就是说，如果有两条竞争链 A 和 B，那么如果验证者在 B 上创建一个区块，并在 B 上得到 +R 的奖励，但区块头可以包含在 A 中（在 Casper 中被称作 “dunkle”），那么在 A 上验证者将会被罚款 -F（可能 F = R）。计算方式改变为：

![04](../../../../images/20180227-pos/04.png)

直觉上，我们可以把工作量证明机制复用到权益证明机制中。在工作量证明机制中，在错的链上生成区块同样有惩罚，但这个惩罚隐含在外部环境中：矿工不得不花费额外的电力并获得或租用额外的硬件。权益证明机制中明确了惩罚机制。这种机制的缺点是对验证者的风险稍大（虽然这个风险会随着时间慢慢变得平滑），但其优点是不需要提前知道验证者。

## 上面介绍了链式权益证明机制如何解决“零风险成本”问题，那现在 BFT 风格的权益证明机制如何工作的呢？

BFT 风格（部分同步）的权益证明机制允许验证者通过发送一种或多种类型的签名消息来对区块进行“投票”，并指定两种规则：

- **终极条件**：确定哈希值何时被认作为不可修改。

- **削减条件**：确定验证者是否有足够理由被怀疑为作弊（例如同时同时投票多个冲突区块）。如果有验证者触犯任意条件，其资产将被删除。

为了说明削减条件可以采取的不同形式，我们将举两个削减条件的例子（后文中，“所有验证者的 2/3” 的意思为 “所有验证者资本总和的 2/3”）。在这些例子中，“PREPARE” 和 “COMMIT” 应该被理解为简单地指代验证者可以发送的两种类型的消息。

1. 如果 `MESSAGES` 包含 `["COMMIT", HASH1, view]` 和 `["COMMIT", HASH2, view]` 形式的信息，其中 `view` 相同但 `HASH1` 和 `HASH2` 不同，且由同一个验证者所签名，那么该验证者遭受惩罚。（不能同时对冲突的区块做签名）。

2. 如果 `MESSAGES` 包含 `["COMMIT", HASH, view1]` 形式的信息，那么**除非** view1 = -1 或同时包含 `["PREPARE", HASH, view1, view2]` 形式的信息（其中 `view2 < view1`），且信息由至少 2/3 的验证者所签名，则对 COMMIT 签名的验证者进行惩罚。（一个 HASH 值只有经过至少 2/3 PREPARE 才能 COMMIT）。

对于合适的削减条件，有两个重要的要求：

- **Accountable safety**：如果存在冲突的 `HASH1` 和 `HASH2`（比如，`HASH1` 和 `HASH2` 不同，并且彼此都不为另一个的后代）已不可变，那么至少 1/3 的验证者违反了某些削减条件。

- **Plausible liveness**：除非所有验证人中至少有 1/3 违反了一些削减条件，那么存在 2/3 的验证者可以产生最终值。

如果我们有一套满足这两个属性的削减条件，那么我们可以激励参与者发送消息，并开始从 economic finality 中受益。

## 一般来说，“经济面上的终局”是什么？

Economic finality 是指，一旦一个区块被生成，或更一般地说，一旦有足够的特定类型的消息被签署，那么将来在任意时间点，想要包含一个冲突的区块的条件是，大量的人愿意消耗大量的资金。如果一个节点看到某个区块已经符合条件，那么这意味他们拥有一个非常强大的经济保证，来确保此区块能够作为共识链的一部分。

economic finality 有两种方式：

1. 如果足够数量的验证者签署了以下的声明，则可以将区块认定为 economically finalized —— “假如区块 B 没有被纳入链中则我将损失 X 数量的资金”。这便向客户端保证了：（1）区块 B 是链的一部分，或者（2）假如验证者通过损失大量的资金来误导客户端。

2. 如果足够多的验证者支持认同区块 B，而且有方式能证明在相同情况下不同于 B 的区块 B' 也被收入了区块，并让验证者损失大量资金，则此区块被视为 economically finalized。如果客户端基于当前情况，验证了该链，并且由于有效性（validity）加不可更改性（finality）是分叉选择规则中优先权的充分条件，于是客户端可以得到保证：（1）区块 B 是链的一部分，或者（2）假如验证者通过损失大量的资金来误导客户端。

这两种方式分别继承自“零风险成本问题”的两个解决方法，通过惩罚错误（比如 COMMIT 不合法的区块）和惩罚不明确性（比如 COMMIT 两个冲突区块）来实现 finality。第一种方法的主要好处是，它更轻量，更易于推理；第二种方法的主要好处是（1）更容易看到诚实的验证者不会受到惩罚，（2）干扰因素对诚实的验证者比较有利——相对于不诚实节点干扰诚实节点所付出的代价，比诚实节点干扰不诚实节点成本要高。

Casper 采用第二种方式。同时可以添加链上机制，验证者可以自愿选择签署第一种方式的 finality 消息，从而增加客户端的效率。

## 所以这和拜占庭容错理论有什么关系？

传统的拜占庭容错理论在 safety 和 liveness 上有类似的需求。首先，传统的拜占庭容错理论只要求 2/3 的验证者是诚实的就可以实现安全。这是一个非常容易实现的模型。传统容错试图证明“如果机制 M 有安全故障，则至少有 1/3 的节点出现故障”，而我们的模型试图证明“如果机制 M 有安全故障，那么至少有 1/3 的节点出现故障，并且即使在故障发生时你离线了，也知道哪些发生了故障”。从 liveness 角度来看，我们的模型更容易，因为我们不需要证明网络能达成共识，我们只是要求证明它不会被阻塞。

幸运的是，我们可以证明额外的问责制需求并不是很难实现。事实上，只要有正确的防御机制，我们可以将任何传统的部分同步或异步拜占庭式容错算法转换为一个可信任的算法。这个证明基本上归结为这样一个事实，即错误可以被彻底地分为几类，并且这些类中的每一类要么被追责（例如，如果你犯了这种类型的错误，你可能会被发现，所以我们可以为它做一个削减条件），要么会与网络延迟混淆（请注意，过早的发送消息的错误与延迟无法区分，因为人们可以通过调整时钟来模拟）。

## 什么是“弱主观性（weak subjectivity）”？

值得注意的是，使用资产来确保“风险成本不为零”的机制确实导致了安全模型的一个变化。假设资产被锁定了四个月，以后可以撤回。假设发生了一次 51％ 攻击，可以重置 10 天的交易。攻击者创建的区块可以被导入到主链中作为渎职证明（“dunkles”），相应的验证者会受到惩罚。但是，假设这种攻击发生在六个月后。这样的话，虽然这些区块可以再被写入链里，但那时犯错的验证者将能够在主链上撤回他们的资金，不会遭受惩罚。

为了解决这个问题，我们引入了一个“重置限制”规则——即，节点会拒绝晚于资产存取期限（四个月）的重置要求。注意，这个规则与协议中的其他规则都不同，这意味着，节点根据看到某些消息的时间会得到不同的共识结果。节点看到某条消息的时间在不同节点之间可能不同；因此我们认为这个规则是“主观的”（或者，熟悉拜占庭容错理论的人可能认为它是一种同步假设）。

但是，这里的“主观性”非常弱：为了使节点进入“错误”链，他们必须在 4 个月后收到原始消息。这只有在两种情况下才有可能：

1. 当一个节点第一次连接到区块链时。

2. 如果某个节点已离线超过四个月。

第一个问题，用户使用链外的方式进行验证。比如向朋友们、区块浏览器或者交易伙伴等请求链上最近的区块的哈希值，并将其认定为规范的。在实践中，这样的区块哈希值很可能只是作为他们用来验证区块链的软件的一部分；不过能够破坏软件检查点的攻击者理论上能够很容易破坏软件本身，没有任何纯粹的经济学验证可以解决这个问题。

请注意，所有这些都只是在一个非常有限的情况下才成为问题：大多数前面的利益相关者合谋攻击网络并创建替代链。大多数时候会假设只有一个合法链可供选择。

此外，请注意，如果链条没有任何硬性分支，那么在工作链的证明中也存在弱主观性假设。比特币已经通过 [bitcoind 0.8.1](https://bitcoin.org/en/release/v0.8.1) 提前两个月进行了硬分叉，修复了某些大型区块无效的数据库问题，从而允许客户端处理 bitcoind 0.7 无法处理的区块，因此用户必须在 2 个月的时间内下载新版本的软件。这本身就是一种弱的主观性假设，因为用户必须在两个月内“登录”才能下载更新以保持正确的链接。

此外，如果需要，社交认证甚至可以通过多种方式实现自动化。比如，（1）[BIP 70](https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki) 要求支付请求包含最近的区块的哈希值，这样用户的客户端软件会在批准付款之前确保它们与商家在同一个链上（也可以通过其他的链上互动方式）。另一种方式是使用 Jeff Coleman 的 [universal hash time](https://www.youtube.com/watch?v=phXohYF0xGo)。使用此方案之后，那么一个攻击链想要成功，将需要在生成合法链的同时秘密生成，这就要求大多数验证者在这段时间内共谋。

## 弱主观性意味着基于权益证明的链必须“锚定”于某个工作量证明的链，来保证其安全么？

简要来说，不需要。

## 具体阐述

在实践中，弱主观性本身对区块链中的安全性假设是一个相当小的补充，。要明白为什么，考虑弱主体性会损害区块链安全的情况。当前世界中，如果社区中的大多数人看到并存储了区块 XXXYYY 的区块哈希值 A，强大企业或国企将有能力说服整个社区其哈希值为 B，但是由于某些原因，强大的势力并不能诱导用户从其他的地方下载客户端软件。

此外，倡导这种方案的“锚定”甚至不是那么安全。所有的锚定显示区块哈希值是在时间 T' < T 时产生的，这并不能证明它是在当时发布的。因此，一个链接到 PoW 链中的 PoS 链可能会遭受这样的攻击：数量众多的节点联合起来，同时产生两条并行的链，锚定两者，发布一个，然后四个月后发布另一个链。

人们可以通过将 PoS 链的全功能“轻客户端”嵌入到 PoW 链中来解决这个问题，这将会防止双重锚定，但是这要求 PoW 链的功能足够丰富以便能够实现这样的客户端——但是目前大多数工作量证明的链并不具备这样的特性。

## 在权益证明机制中，可以在经济上惩罚审查（censorship）吗？

与重置比起来，审查更难被分辨。区块链本身并不能直接区分“A 用户试图发送交易 X，但没有被公正地审查”、“A 用户尝试发送交易 X，但由于交易费用不足而无法被收入区块链”以及“A 用户从来没有尝试发送交易 X”。好在，有许多技术可以用来缓解审查问题。

首先是阻止问题的审查阻力。在该方案的较弱版本中，该协议被设计成图灵完备的，验证者甚至无法知道某个交易在花费大量运算之后会不会出现预期外的行为，这样会使其面临拒绝服务攻击。这是[阻止 DAO 软分叉](http://hackingdistributed.com/2016/07/05/eth-is-more-resilient-to-censorship/)的原因。

在该计划的更强版本中，交易可以在近期或中期的将来某个时候触发保证效果。用户可以发送多笔相互关联的交易及利用可预期的第三方资讯来导致一些未来的事件，想要进行社差的验证者要等到交易被写入区块（并且经济上不可修改）才能知道发生的事件，但此时阻止交易已经太晚。即便过滤掉将来所有相关的交易，验证者想阻止的事件还是会发生。请注意，在这个方案中，验证者仍然可以尝试阻止所有的交易，或是所有的交易都没有包含某些正式的证明，证明它们不会导致任何不良后果，但这会导致禁止一系列非常广泛的交易，从而实质上破坏整个系统，因为这会导致验证人失去价值，因为他们的作为加密货币的资产将缩水。

其次，由 [Adam Back 所描述的](https://www.reddit.com/r/Bitcoin/comments/4j7pfj/adam_backs_clever_mechanism_to_prevent_miners/d34t9xa)，要求交易进行 [timelock-encrypted](https://www.gwern.net/Self-decrypting%20files)。因此，验证人将在不知道内容的情况下包含交易，并且以后才能自动显示内容，但那时已经无法排除交易。然而，如果验证者的行为足够邪恶，他们可能仅仅同意包含带有密码证明的交易（如利用 zkSNARK 等零知识证明）。这可以强制让用户必须去下载相关的软件，但验证者可以直接提供软件下载。这这样的游戏中，用户是有动力配合的。

或许可以说，在权益证明机制中最有方案是，用户可以安装包含一个硬分叉的软件更新，可以移除恶意验证者。这个方案并不比安装软件更新来实现更“友好的审查”更困难。因此，所有这一切都是适度有效的，尽管它确实以降低区块链交互速度为代价（注意该计划必须是强制性的才能生效；否则恶意验证者可以更容易地简单地过滤加密事务而不过滤更快的未加密事务）。

第三个方法，在链分叉时，将检测审查的机制加入到分叉选择规则中。这个想法很简单。节点监视网络的交易情况，如果他们在足够长的时间内看到某笔交易费用足够高，那么它们会为不包括该交易的区块链分配一个较低的“分数”。如果所有节点都遵循这一策略，那么最终弱势的链也会因为收入了这个交易而让其他诚实的节点都转而选择这条链。这个方案的主要缺点是，离线的节点还是记录着强势链，如果审查是暂时的，并且在审查结束后节点重新上线，那么他们将与线上节点产生分歧。因此，这种方案应该被当做紧急情况下比如硬分叉发生时节点间的协调工具，而在日常的分叉选择中则不适合。

## 验证者如何选择？什么是 stake grinding？

在任何链式的权益证明机制中，需要一些机制来随机选择当前有效的验证者中的哪个验证者可以生成下一个区块。例如，当前的验证者集合由 Alice（40 以太币）、Bob（30 以太币）、Charlie（20 以太币）以及 David（10 以太币），那么希望下一个区块创造者为 Alice 的概率为 40%，为 Bob 的概率为 30%，以此类推（在实践中，我们会希望选出来的是无限的候选人序列而不是某一个，这样当前面的缺席时，后面的就可以进行补位，但这不影响其本质）。在非链式的算法中，我们也常常需要随机性。

`Stake grinding` 是一类攻击：验证者执行一些计算或采取其他一些步骤来尝试以自己的偏好来影响随机性。例如：

1. 在 [Peercoin](https://bitcointalk.org/index.php?topic=131901.0) 中，验证者可搜寻各种参数的组合并找到特定的参数来增加他们产生有效区块的次数。

2. 在一个目前已经不用的方式里，第 N+1 个区块的随机性取决于第 N 个区块里的签名。这让验证者可以重复产生新的签名，直到找到一个特殊的签名，能让他们预测并掌握下一个区块，并由此控制系统。

3. 在 NXT 中，第 N+1 个区块的随机性取决于产生第 N 个区块的验证者。折让验证者可以借由跳过一个产生区块的机会来影响随机性。虽然这么做的机会成本是损失一个区块奖赏，但有时候新产生的随机种子可以让验证者在未来数十个区块中获得高于平均区块奖赏的奖励。详细可以参考[这里](http://vitalik.ca/files/randomness.html)。

（1）和（2）比较容易解决，一般的做法是要求验证者先存入资金来避免其一直改变地址来找到可以影响随机性的值，并避免使用可以轻易被操纵的信息，比如区块中的签名。（3）有几种主要的策略。

第一种是使用 [secret sharing](https://en.wikipedia.org/wiki/Secret_sharing) 或者 [deterministic threshold signatures](https://eprint.iacr.org/2002/081.pdf)，并让验证者共同产生随机值。除非大多数验证者串通，否则此方案对所有操作都是有用的（在某些情况下，根据具体实现，33-50％ 的验证者就会出现操作的干扰，导致协议保持 liveness 的几率降低到 67％）。

其次是使用密码学的方式：验证者事先提交一些信息（例如，公布 `sha3(x)`），然后必须在块中发布 `x`。`x` 被添加到随机池中。理论上有两种潜在的攻击：

1. 在提交时对 x 做手脚。这是不切实际的，因为随机性结果会基于多个参与者的值，并且即便只有一个是诚实的，那么输出也将是均匀分布。均匀分布与任意多个任意偏差分布异或，仍然可以得到均匀分布。

2. 选择性的公布区块。然而，这种攻击花费的机会成本为一个区块奖励，并且因为该方案能保证人们无法查看除了下一个验证者之外的其他验证者，所以它几乎无法提供超过一个区块奖励的收入。唯一的例外是，假如跳过验证，替补上来的验证者和下一个区块的验证者可能是同一个验证者。如果这些情况是一个严重的问题，那么我们可以对跳过验证进行明确的惩罚。

第三个方法是使用 [Iddo Bentov 提出的 “majority beacon”](https://arxiv.org/pdf/1406.5694.pdf)，基于之前生成的（也用 beacon 方式）N 个随机数字中的每个 bit 的值的多数来决定生成新的随机数字（即，如果大多数数字的第一位的值为 1，则结果的第一位则为 1，否则为 0，以此类推）。攻击的成本为 `~C * sqrt(N)`，其中 `C` 是攻击其他 beacon 生成的随机数字的成本。总之，存在许多已知的 `stake grinding` 解决方案。这个问题更像是 [differential cryptanalysis](https://en.wikipedia.org/wiki/Differential_cryptanalysis) 而不是 [the halting problem](https://en.wikipedia.org/wiki/Halting_problem)，这是让权益证明机制的设计者能够理解并知道如何克服的问题，而不是根本无法避免的缺陷。

## 针对 Casper 的 51% 攻击是什么样的？

最基本的 “51%” 攻击是 **finality reversion**：验证者已经确认的区块 A，然后产生一些竞争区块 A'，这样就打破了区块链的不可修改性。在这种情况下，存在两个不兼容的最终历史记录，导致了区块链的分叉。这需要依赖在链外通过社群的协调来决定应该选择哪条链。

协调的方式有很多种，比如通过社交媒体、区块链浏览器提供商或交易所之间的私人渠道、各种在线论坛等。最终的原则是，“哪条先被最终确认就选择哪条”。另一个选择依靠“市场共识”：在很短的时间里，两条分叉都可以在交易所中进行交易，直到一条因为价值更高而胜出。在这种情况中，“哪条先被最终确认就选哪条”的原则将成为市场选择的 Schelling point。实践中这两种方法可能会组合使用。

一旦链达成共识，用户（验证者、轻量节点和全量节点）将能够通过软件界面中的特殊选项手动将获胜的区块哈希值插入到其客户端中。

